import argparse

import os

import spotipy
from datetime import date

scopes = 'playlist-modify-public playlist-modify-private user-top-read user-read-private'

class PlaylistCreator:
    def __init__(self):
        self.sp = spotipy.Spotify(
            auth_manager=spotipy.SpotifyOAuth(client_id=os.environ['SPOTIPY_CLIENT_ID'],
                                              client_secret=os.environ['SPOTIPY_CLIENT_SECRET'],
                                              redirect_uri=os.environ['SPOTIPY_REDIRECT_URI'],
                                              scope=scopes)
        )

    def get_top_tracks(self, range: str, limit=50, offset=0, accumulated_results=None):
        if accumulated_results is None:
            accumulated_results = []

        batch_limit = min(50, limit)
        results = self.sp.current_user_top_tracks(time_range=range, limit=batch_limit, offset=offset)
        if not results or not results['items']:
            return accumulated_results

        accumulated_results.extend([i['id'] for i in results['items']])
        if len(results['items']) < batch_limit:
            return accumulated_results

        if limit > batch_limit:
            return self.get_top_tracks(range, limit - batch_limit, offset + batch_limit, accumulated_results)

        return accumulated_results

    def get_recommendations(self,
                            seed_artists=None,
                            seed_genres=None,
                            seed_tracks=None,
                            limit=50,
                            country=None,
                            accumulated_results=None):
        if accumulated_results is None:
            accumulated_results = []

        batch_limit = min(100, limit)
        results = self.sp.recommendations(seed_artists, seed_genres, seed_tracks, limit, 'SE')
        if not results:
            return accumulated_results

    def create_playlist(self, name: str, description: str, track_ids_list: list):
        user_id = self.sp.me()['id']
        result = self.sp.user_playlist_create(user_id, name, description=description)
        self.sp.playlist_add_items(result['id'], track_ids_list)
        return result['name']


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-r', '--time_range',
                        default='short_term',
                        choices=['short_term', 'medium_term', 'long_term'],
                        help='Time range for picking top tracks')
    parser.add_argument('-l', '--limit',
                        default=50,
                        help='Amount of top tracks to pick')
    args = parser.parse_args()
    playlist_creator = PlaylistCreator()
    top_tracks_ids = playlist_creator.get_top_tracks(args.time_range, 100)
    current_top_playlist = playlist_creator.create_playlist(f"top_{str(date.today())}",
                                                            f"Generated by yt2sp for {args.time_range}",
                                                            top_tracks_ids)
    result = playlist_creator.get_recommendations(seed_tracks=top_tracks_ids[0:4], limit=100)


if __name__ == '__main__':
    main()
